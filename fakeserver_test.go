package acme

import (
	"crypto"
	"crypto/rsa"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strconv"
	"sync"

	"github.com/tommie/acme-go/protocol"
	"gopkg.in/square/go-jose.v2"
)

var errBadNonce = errors.New("bad nonce")

type fakeACMEServer struct{}

// newFakeACMEServer creates a fake ACME server and starts a listener.
func newFakeACMEServer() (*fakeACMEServer, *httptest.Server) {
	as := &fakeACMEServer{}
	mux := http.NewServeMux()
	hts := httptest.NewServer(mux)
	u, err := url.Parse(hts.URL)
	if err != nil {
		panic(err)
	}
	RegisterBoulderHTTP(mux, u, as, newIntNonceSource())

	return as, hts
}

func (s *fakeACMEServer) RegisterAccount(accountKey crypto.PublicKey, reg *Registration) (*Registration, error) {
	reg.URI = "http://example.com/reg/1"
	return reg, nil
}

func (s *fakeACMEServer) Authorization(uri string) (*Authorization, error) {
	return nil, fmt.Errorf("unimplemented: Authorization")
}

func (s *fakeACMEServer) Certificate(uri string) (*Certificate, error) {
	return nil, fmt.Errorf("unimplemented: Certificate")
}

func (s *fakeACMEServer) Account(accountKey crypto.PublicKey) ServerAccount {
	return s
}

func (s *fakeACMEServer) AuthorizeIdentity(id Identifier) (*Authorization, error) {
	return nil, &protocol.ServerError{
		StatusCode: http.StatusUnauthorized,
		Problem: &protocol.Problem{
			Type:   protocol.Unauthorized,
			Title:  "mock error",
			Detail: "mock error detail",
			Status: http.StatusUnauthorized,
		},
	}
}

func (s *fakeACMEServer) IssueCertificate(csr []byte) (*Certificate, error) {
	return nil, fmt.Errorf("unimplemented: IssueCertificate")
}

func (s *fakeACMEServer) RevokeCertificate(cert []byte) error {
	return fmt.Errorf("unimplemented: RevokeCertificate")
}

func (s *fakeACMEServer) UpdateRegistration(reg *Registration) (*Registration, error) {
	return reg, nil
}

func (s *fakeACMEServer) ValidateChallenge(uri string, req protocol.Response) (protocol.Challenge, error) {
	return nil, fmt.Errorf("unimplemented: ValidateChallenge")
}

// intNonceSource is a simple in-memory nonce source using a sequence
// number and a map.
type intNonceSource struct {
	i      int
	unseen map[string]struct{}
	mu     sync.Mutex
}

// newIntNonceSource creates a new nonce source based on sequence
// numbers.
func newIntNonceSource() *intNonceSource {
	return &intNonceSource{
		unseen: map[string]struct{}{},
	}
}

func (ns *intNonceSource) Nonce() (string, error) {
	ns.mu.Lock()
	defer ns.mu.Unlock()

	ns.i++
	s := strconv.Itoa(ns.i)
	ns.unseen[s] = struct{}{}

	return s, nil
}

func (ns *intNonceSource) Verify(s string) error {
	ns.mu.Lock()
	defer ns.mu.Unlock()

	if _, ok := ns.unseen[s]; ok {
		delete(ns.unseen, s)
		return nil
	}

	return errBadNonce
}

var (
	// testJWK is a JSONWebKey used for tests. Generated by protocol.mustGenerateTestJWK.
	testJWK = mustUnmarshalJWK(`{
	"kty": "RSA",
	"n": "1-OrKVWRL2mjMk8CQS4aoX0vY2RHjjPQbE-CwtSnXDmw9pe1NB3xc9LBrB_pWpjrJKzyJm8PEz4YGDNVC8UzCw",
	"e": "AQAB",
	"d": "vYhi_CbjD3zuiXxTvmV7e8srj1a6e12B3ZTwd5u6Unu13MqiceywGjXP98z18uCrAYgxyHHGQY6X7Ahfm2riAQ",
	"p": "23IPuW88sFRlPOlJ_OUWjQKE7DOXCFyUbeWxD8unk18",
	"q": "-9n1DN65zlVdGXzwxbt1tIxt2Jj8aQMrr-qa_i-Ni9U"
}`)
	// testPublicKey is the raw crypto.PublicKey part of testJWK.
	testPublicKey = testJWK.Key.(*rsa.PrivateKey).Public()
)

// mustUnmarshalJWK takes a JSON string and unmarshals the key. Panics on error.
func mustUnmarshalJWK(s string) *jose.JSONWebKey {
	ret := &jose.JSONWebKey{}
	if err := json.Unmarshal([]byte(s), ret); err != nil {
		panic(err)
	}
	return ret
}
